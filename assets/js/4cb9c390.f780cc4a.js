"use strict";(self.webpackChunkgillian_platform_github_io=self.webpackChunkgillian_platform_github_io||[]).push([[860],{3905:(e,t,i)=>{i.d(t,{Zo:()=>m,kt:()=>d});var n=i(7294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,n,r=function(e,t){if(null==e)return{};var i,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var c=n.createContext({}),s=function(e){var t=n.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},m=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var i=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=s(i),d=r,f=p["".concat(c,".").concat(d)]||p[d]||u[d]||a;return i?n.createElement(f,o(o({ref:t},m),{},{components:i})):n.createElement(f,o({ref:t},m))}));function d(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=i.length,o=new Array(a);o[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<a;s++)o[s]=i[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}p.displayName="MDXCreateElement"},4404:(e,t,i)=>{i.d(t,{Z:()=>r});var n=i(7294);const r=e=>{let{publi:t}=e;return n.createElement(n.Fragment,null,n.createElement("h3",null,"Authors"),n.createElement("ul",null,t.authors.map((e=>n.createElement("li",{key:e},e)))),n.createElement("h3",null,"Abstract"),n.createElement("p",null,t.abstract),n.createElement("h3",null,"Venue"),n.createElement("p",null,t.venue),n.createElement("h3",null,"Publication Date"),n.createElement("p",null,t.date),n.createElement("h3",null,"Identifiers"),n.createElement("ul",null,Object.entries(t.identifiers).map((e=>{let[t,{name:i,link:r}]=e;return n.createElement("li",{key:t},t,":",n.createElement("a",{href:r},i))}))))}},9686:(e,t,i)=>{i.d(t,{F:()=>l,p:()=>c});const n="Jos\xe9 Fragoso Santos",r="Petar Maksimovi\u0107",a="Sacha-\xc9lie Ayoun",o="Philippa Gardner",l={title:"Gillian, Part I: Parametric Symbolic Execution for Real-World Programming Languages",authors:[n,r,a,o],abstract:"We introduce Gillian, a language-independent framework for the development of symbolic analysis tools. Gillian supports whole-program symbolic testing, semi-automatic verification, and automatic compositional testing using bi-abduction. It comes with meta-theoretical results that are parametric on the memory model of the target language and a modular implementation that closely follows the meta-theory, all designed to minimise the instantiation effort of the user. In this paper, we focus on the parametric symbolic execution engine at the core of Gillian and its associated meta-theory. We instantiate Gillian to obtain symbolic testing tools for JavaScript and C, and use these tools to find bugs in real-world code, with times that either outperform or are competitive with the existing language-specific tools.",venue:"PLDI 2020: Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation",date:"June 2020",identifiers:{doi:{name:"10.1145/3385412.3386014",link:"https://doi.org/10.1145/3385412.3386014"}}},c={title:"Gillian, Part II: Real-World Verification for JavaScript and C",authors:[r,a,n,o],abstract:"We introduce verification based on separation logic to Gillian, a multi-language platform for the development of symbolic analysis tools which is parametric on the memory model of the target language. Our work develops a methodology for constructing compositional memory models for Gillian, leading to a unified presentation of the JavaScript and C memory models. We verify the JavaScript and C implementations of the AWS Encryption SDK message header deserialisation module, specifically designing common abstractions used for both verification tasks, and find two bugs in the JavaScript and three bugs in the C implementation.",date:"July 2021",venu:"CAV 2021: International Conference on Computer Aided Verification",identifiers:{doi:{name:"10.1007/978-3-030-81688-9_38",link:"https://doi.org/doi:10.1007/978-3-030-81688-9_38"}}}},5091:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>m,contentTitle:()=>c,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var n=i(7462),r=(i(7294),i(3905)),a=i(4404),o=i(9686);const l={id:"pldi20-ref",title:"Gillian Part I - PLDI 2020",hide_title:!0,sidebar_position:1},c="Gillian, Part I: Parametric Symbolic Execution for Real-World Programming Languages",s={unversionedId:"Publications/Gillian Part I - PLDI 2020/pldi20-ref",id:"Publications/Gillian Part I - PLDI 2020/pldi20-ref",title:"Gillian Part I - PLDI 2020",description:"",source:"@site/docs/Publications/Gillian Part I - PLDI 2020/index.mdx",sourceDirName:"Publications/Gillian Part I - PLDI 2020",slug:"/Publications/Gillian Part I - PLDI 2020/",permalink:"/docs/Publications/Gillian Part I - PLDI 2020/",draft:!1,editUrl:"https://github.com/GillianPlatform/GillianPlatform.github.io/edit/source/docs/Publications/Gillian Part I - PLDI 2020/index.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"pldi20-ref",title:"Gillian Part I - PLDI 2020",hide_title:!0,sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Publications",permalink:"/docs/Instantiations/JavaScript/papers"},next:{title:"Differences between Paper and Implementation",permalink:"/docs/Publications/Gillian Part I - PLDI 2020/pldi20-diff"}},m={},u=[],p={toc:u};function d(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"gillian-part-i-parametric-symbolic-execution-for-real-world-programming-languages"},"Gillian, Part I: Parametric Symbolic Execution for Real-World Programming Languages"),(0,r.kt)(a.Z,{publi:o.F,mdxType:"Reference"}))}d.isMDXComponent=!0}}]);