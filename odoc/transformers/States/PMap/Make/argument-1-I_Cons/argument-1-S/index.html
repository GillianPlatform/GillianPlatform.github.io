<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (transformers.States.PMap.Make.I_Cons.S)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../../index.html">Index</a> &#x00BB; <a href="../../../../../index.html">transformers</a> &#x00BB; <a href="../../../../index.html">States</a> &#x00BB; <a href="../../../index.html">PMap</a> &#x00BB; <a href="../../index.html">Make</a> &#x00BB; <a href="../index.html">I_Cons</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Parameter <code><span>I_Cons.S</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_yojson"><a href="#val-to_yojson" class="anchor"></a><code><span><span class="keyword">val</span> to_yojson : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Yojson</span>.Safe.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_yojson"><a href="#val-of_yojson" class="anchor"></a><code><span><span class="keyword">val</span> of_yojson : <span><span class="xref-unresolved">Yojson</span>.Safe.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Ppx_deriving_yojson_runtime</span>.error_or</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-err_t"><a href="#type-err_t" class="anchor"></a><code><span><span class="keyword">type</span> err_t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_err_t"><a href="#val-pp_err_t" class="anchor"></a><code><span><span class="keyword">val</span> pp_err_t : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-err_t">err_t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-show_err_t"><a href="#val-show_err_t" class="anchor"></a><code><span><span class="keyword">val</span> show_err_t : <span><a href="#type-err_t">err_t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-err_t_to_yojson"><a href="#val-err_t_to_yojson" class="anchor"></a><code><span><span class="keyword">val</span> err_t_to_yojson : <span><a href="#type-err_t">err_t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Yojson</span>.Safe.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-err_t_of_yojson"><a href="#val-err_t_of_yojson" class="anchor"></a><code><span><span class="keyword">val</span> err_t_of_yojson : 
  <span><span class="xref-unresolved">Yojson</span>.Safe.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-err_t">err_t</a> <span class="xref-unresolved">Ppx_deriving_yojson_runtime</span>.error_or</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-action"><a href="#type-action" class="anchor"></a><code><span><span class="keyword">type</span> action</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pred"><a href="#type-pred" class="anchor"></a><code><span><span class="keyword">type</span> pred</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-action_from_str"><a href="#val-action_from_str" class="anchor"></a><code><span><span class="keyword">val</span> action_from_str : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-action">action</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-action_to_str"><a href="#val-action_to_str" class="anchor"></a><code><span><span class="keyword">val</span> action_to_str : <span><a href="#type-action">action</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pred_from_str"><a href="#val-pred_from_str" class="anchor"></a><code><span><span class="keyword">val</span> pred_from_str : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pred">pred</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pred_to_str"><a href="#val-pred_to_str" class="anchor"></a><code><span><span class="keyword">val</span> pred_to_str : <span><a href="#type-pred">pred</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Returns an empty state</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-execute_action"><a href="#val-execute_action" class="anchor"></a><code><span><span class="keyword">val</span> execute_action : 
  <span><a href="#type-action">action</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-t">t</a> * <span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span>, <a href="#type-err_t">err_t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>
    <a href="../../../../../../gillian/Monadic/Delayed/index.html#type-t">Gillian.Monadic.Delayed.t</a></span></span></code></div><div class="spec-doc"><p>Execute an action</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-consume"><a href="#val-consume" class="anchor"></a><code><span><span class="keyword">val</span> consume : 
  <span><a href="#type-pred">pred</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-t">t</a> * <span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span>, <a href="#type-err_t">err_t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>
    <a href="../../../../../../gillian/Monadic/Delayed/index.html#type-t">Gillian.Monadic.Delayed.t</a></span></span></code></div><div class="spec-doc"><p>Consume a predicate with the given ins</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-produce"><a href="#val-produce" class="anchor"></a><code><span><span class="keyword">val</span> produce : 
  <span><a href="#type-pred">pred</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <a href="../../../../../../gillian/Monadic/Delayed/index.html#type-t">Gillian.Monadic.Delayed.t</a></span></span></code></div><div class="spec-doc"><p>Produce a predicate with the given ins and outs</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span><span class="keyword">val</span> compose : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../../../../../gillian/Monadic/Delayed/index.html#type-t">Gillian.Monadic.Delayed.t</a></span></span></code></div><div class="spec-doc"><p>Compose two states together</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_exclusively_owned"><a href="#val-is_exclusively_owned" class="anchor"></a><code><span><span class="keyword">val</span> is_exclusively_owned : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>bool <a href="../../../../../../gillian/Monadic/Delayed/index.html#type-t">Gillian.Monadic.Delayed.t</a></span></span></code></div><div class="spec-doc"><p>For Freeable: if a state can be freed. Must only be true if no non-empty state can be composed with the state. The Expr list is irrelevant; it's required because of Gillian-C.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>If this state is observably empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_concrete"><a href="#val-is_concrete" class="anchor"></a><code><span><span class="keyword">val</span> is_concrete : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>If this state is entirely made up of concrete expressions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-instantiate"><a href="#val-instantiate" class="anchor"></a><code><span><span class="keyword">val</span> instantiate : 
  <span><span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a> * <span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span></span></code></div><div class="spec-doc"><p>Instantiates this state with a list of arguments. This is used by PMap, either in static mode with the 'instantiate' action, or in dynamic mode when accessing a missing index.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assertions"><a href="#val-assertions" class="anchor"></a><code><span><span class="keyword">val</span> assertions : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-pred">pred</a> * <span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span> * <span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> list</span>)</span> list</span></span></code></div><div class="spec-doc"><p>The list of core predicates corresponding to the state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assertions_others"><a href="#val-assertions_others" class="anchor"></a><code><span><span class="keyword">val</span> assertions_others : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../../gillian/Gillian/Gil_syntax/Asrt/index.html#type-atom">Gillian.Gil_syntax.Asrt.atom</a> list</span></span></code></div><div class="spec-doc"><p>The list of assertions that aren't core predicates corresponding to the state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-can_fix"><a href="#val-can_fix" class="anchor"></a><code><span><span class="keyword">val</span> can_fix : <span><a href="#type-err_t">err_t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>If the error can be fixed</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_fixes"><a href="#val-get_fixes" class="anchor"></a><code><span><span class="keyword">val</span> get_fixes : <span><a href="#type-err_t">err_t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="#type-pred">pred</a> <a href="../../../../MyAsrt/index.html#type-t">MyAsrt.t</a></span> list</span> list</span></span></code></div><div class="spec-doc"><p>Get the fixes for an error, as a list of fixes -- a fix is a list of core predicates to produce onto the state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_recovery_tactic"><a href="#val-get_recovery_tactic" class="anchor"></a><code><span><span class="keyword">val</span> get_recovery_tactic : 
  <span><a href="#type-err_t">err_t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../../gillian/Gillian/Gil_syntax/Expr/index.html#type-t">Gillian.Gil_syntax.Expr.t</a> <a href="../../../../../../gillian/Engine/General/Recovery_tactic/index.html#type-t">States.MyMonadicSMemory.Recovery_tactic.t</a></span></span></code></div><div class="spec-doc"><p>The recovery tactic to attempt to resolve an error, by eg. unfolding predicates</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lvars"><a href="#val-lvars" class="anchor"></a><code><span><span class="keyword">val</span> lvars : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../../../gillian/Gillian/Utils/Containers/SS/index.html#type-t">States.MyMonadicSMemory.Containers.SS.t</a></span></code></div><div class="spec-doc"><p>The set of logical variables in the state</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alocs"><a href="#val-alocs" class="anchor"></a><code><span><span class="keyword">val</span> alocs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../../../gillian/Gillian/Utils/Containers/SS/index.html#type-t">States.MyMonadicSMemory.Containers.SS.t</a></span></code></div><div class="spec-doc"><p>The set of abstract locations in the state</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-substitution_in_place"><a href="#val-substitution_in_place" class="anchor"></a><code><span><span class="keyword">val</span> substitution_in_place : 
  <span><a href="../../../../../../gillian/Gillian/Symbolic/Subst/index.html#type-t">Gillian.Symbolic.Subst.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <a href="../../../../../../gillian/Monadic/Delayed/index.html#type-t">Gillian.Monadic.Delayed.t</a></span></span></code></div><div class="spec-doc"><p>Applies a substitution to the state. This can branch, eg. when attempting to resolve equality of expressions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty print the state</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_actions"><a href="#val-list_actions" class="anchor"></a><code><span><span class="keyword">val</span> list_actions : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-action">action</a> * <span>string list</span> * <span>string list</span>)</span> list</span></span></code></div><div class="spec-doc"><p>(Debug only) Return all available (action * arguments * outputs)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_preds"><a href="#val-list_preds" class="anchor"></a><code><span><span class="keyword">val</span> list_preds : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-pred">pred</a> * <span>string list</span> * <span>string list</span>)</span> list</span></span></code></div><div class="spec-doc"><p>(Debug only) Return all available (predicates * ins * outs)</p></div></div></div></body></html>
