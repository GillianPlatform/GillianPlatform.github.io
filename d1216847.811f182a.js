(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{148:function(e,t,i){"use strict";i.r(t),i.d(t,"frontMatter",(function(){return o})),i.d(t,"metadata",(function(){return c})),i.d(t,"rightToc",(function(){return l})),i.d(t,"default",(function(){return u}));var a=i(1),r=i(9),n=(i(0),i(155)),o={id:"references",title:"Gillian-JS: References"},c={id:"js/references",title:"Gillian-JS: References",description:"## JaVerT: JavaScript Verification Toolchain",source:"@site/docs/js/references.md",permalink:"/docs/js/references",editUrl:"https://github.com/GillianPlatform/GillianPlatform.github.io/edit/source/docs/js/references.md",sidebar:"someSidebar",previous:{title:"Gillian-JS: Symbolic Testing",permalink:"/docs/js/cosette"},next:{title:"Gillian-C: Introduction",permalink:"/docs/c/intro"}},l=[{value:"JaVerT: JavaScript Verification Toolchain",id:"javert-javascript-verification-toolchain",children:[{value:"Authors",id:"authors",children:[]},{value:"Abstract",id:"abstract",children:[]},{value:"Venue",id:"venue",children:[]},{value:"Publication Date",id:"publication-date",children:[]},{value:"Identifiers",id:"identifiers",children:[]}]},{value:"Cosette: Symbolic Execution For JavaScript",id:"cosette-symbolic-execution-for-javascript",children:[{value:"Authors",id:"authors-1",children:[]},{value:"Abstract",id:"abstract-1",children:[]},{value:"Venue",id:"venue-1",children:[]},{value:"Publication Date",id:"publication-date-1",children:[]},{value:"Identifiers",id:"identifiers-1",children:[]}]},{value:"JaVerT2.0: Compositional Symbolic Execution for JavaScript",id:"javert20-compositional-symbolic-execution-for-javascript",children:[{value:"Authors",id:"authors-2",children:[]},{value:"Abstract",id:"abstract-2",children:[]},{value:"Venue",id:"venue-2",children:[]},{value:"Publication Date",id:"publication-date-2",children:[]},{value:"Identifiers",id:"identifiers-2",children:[]}]}],s={rightToc:l};function u(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(n.b)("wrapper",Object(a.a)({},s,i,{components:t,mdxType:"MDXLayout"}),Object(n.b)("h2",{id:"javert-javascript-verification-toolchain"},"JaVerT: JavaScript Verification Toolchain"),Object(n.b)("h3",{id:"authors"},"Authors"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Jos\xe9 Fragoso Santos"),Object(n.b)("li",{parentName:"ul"},"Petar Maksimovi\u0107"),Object(n.b)("li",{parentName:"ul"},"Daiva Naud\u017ei\u016bnien\u0117"),Object(n.b)("li",{parentName:"ul"},"Thomas Wood"),Object(n.b)("li",{parentName:"ul"},"Philippa Gardner")),Object(n.b)("h3",{id:"abstract"},"Abstract"),Object(n.b)("p",null,"The dynamic nature of JavaScript and its complex semantics make it a difficult target for logic-based verification. We introduce JaVerT, a semi-automatic JavaScript Verification Toolchain, based on separation logic and aimed at the specialist developer wanting rich, mechanically verified specifications of critical JavaScript code. To specify JavaScript programs, we design abstractions that capture its key heap structures (for example, prototype chains and function closures), allowing the developer to write clear and succinct specifications with minimal knowledge of the JavaScript internals. To verify JavaScript programs, we develop JaVerT, a verification pipeline consisting of: JS-2-JSIL, a well-tested compiler from JavaScript to JSIL, an intermediate goto language capturing the fundamental dynamic features of JavaScript; JSIL Verify, a semi-automatic verification tool based on a sound JSIL separation logic; and verified axiomatic specifications of the JavaScript internal functions. Using JaVerT, we verify functional correctness properties of: data-structure libraries (key-value map, priority queue) written in an object-oriented style; operations on data structures such as binary search trees (BSTs) and lists; examples illustrating function closures; and test cases from the official ECMAScript test suite. The verification times suggest that reasoning about larger, more complex code using JaVerT is feasible."),Object(n.b)("h3",{id:"venue"},"Venue"),Object(n.b)("p",null,"PACMPL, vol. 2(POPL), pp. 50:1\u201350:33"),Object(n.b)("h3",{id:"publication-date"},"Publication Date"),Object(n.b)("p",null,"2019"),Object(n.b)("h3",{id:"identifiers"},"Identifiers"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"DOI:",Object(n.b)("a",Object(a.a)({parentName:"li"},{href:"http://dx.doi.org/10.1145/3158138"}),"doi:10.1145/3158138"))),Object(n.b)("h2",{id:"cosette-symbolic-execution-for-javascript"},"Cosette: Symbolic Execution For JavaScript"),Object(n.b)("h3",{id:"authors-1"},"Authors"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Jos\xe9 Fragoso Santos"),Object(n.b)("li",{parentName:"ul"},"Petar Maksimovi\u0107"),Object(n.b)("li",{parentName:"ul"},"Daiva Naud\u017ei\u016bnien\u0117"),Object(n.b)("li",{parentName:"ul"},"Thomas Wood"),Object(n.b)("li",{parentName:"ul"},"Philippa Gardner")),Object(n.b)("h3",{id:"abstract-1"},"Abstract"),Object(n.b)("p",null,"We present a framework for trustworthy symbolic execution of JavaScripts programs, whose aim is to assist developers in the testing of their code: the developer writes symbolic tests for which the framework provides concrete counter-models. We create the framework following a new, general methodology for designing compositional program analyses for dynamic languages. We prove that the underlying symbolic execution is sound and does not generate false positives. We establish additional trust by using the theory to precisely guide the implementation and by thorough testing. We apply our framework to whole-program symbolic testing of real-world JavaScript libraries and compositional debugging of separation logic specifications of JavaScript programs."),Object(n.b)("h3",{id:"venue-1"},"Venue"),Object(n.b)("p",null,"Proceedings of the 20th International Symposium on Principles and Practice of Declarative Programming, PPDP 2018, Frankfurt am Main, Germany, September 03-05, 2018, pp. 11:1\u201311:14"),Object(n.b)("h3",{id:"publication-date-1"},"Publication Date"),Object(n.b)("p",null,"Sep 2018"),Object(n.b)("h3",{id:"identifiers-1"},"Identifiers"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"DOI:",Object(n.b)("a",Object(a.a)({parentName:"li"},{href:"http://dx.doi.org/10.1145/3236950.3236956"}),"doi:10.1145/3236950.3236956"))),Object(n.b)("h2",{id:"javert20-compositional-symbolic-execution-for-javascript"},"JaVerT2.0: Compositional Symbolic Execution for JavaScript"),Object(n.b)("h3",{id:"authors-2"},"Authors"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Jos\xe9 Fragoso Santos"),Object(n.b)("li",{parentName:"ul"},"Petar Maksimovi\u0107"),Object(n.b)("li",{parentName:"ul"},"Gabriela Sampaio"),Object(n.b)("li",{parentName:"ul"},"Philippa Gardner")),Object(n.b)("h3",{id:"abstract-2"},"Abstract"),Object(n.b)("p",null,"We propose a novel, unified approach to the development of compositional symbolic execution tools, bridging the gap between classical symbolic execution and compositional program reasoning based on separation logic. Using this approach, we build JaVerT 2.0, a symbolic analysis tool for JavaScript that follows the language semantics without simplifications. JaVerT 2.0 supports whole-program symbolic testing, verification, and, for the first time, automatic compositional testing based on bi-abduction. The meta-theory underpinning JaVerT 2.0 is developed modularly, streamlining the proofs and informing the implementation. Our explicit treatment of symbolic execution errors allows us to give meaningful feedback to the developer during wholeprogram symbolic testing and guides the inference of resource of the bi-abductive execution. We evaluate the performance of JaVerT 2.0 on a number of JavaScript data-structure libraries, demonstrating: the scalability of our whole-program symbolic testing; an improvement over the state-of-the-art in JavaScript verification; and the feasibility of automatic compositional testing for JavaScript."),Object(n.b)("h3",{id:"venue-2"},"Venue"),Object(n.b)("p",null,"PACMPL 3(POPL)"),Object(n.b)("h3",{id:"publication-date-2"},"Publication Date"),Object(n.b)("p",null,"2019"),Object(n.b)("h3",{id:"identifiers-2"},"Identifiers"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"DOI:",Object(n.b)("a",Object(a.a)({parentName:"li"},{href:"http://dx.doi.org/10.1145/3290379"}),"doi:10.1145/3290379"))))}u.isMDXComponent=!0},155:function(e,t,i){"use strict";i.d(t,"a",(function(){return p})),i.d(t,"b",(function(){return m}));var a=i(0),r=i.n(a);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function c(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,a,r=function(e,t){if(null==e)return{};var i,a,r={},n=Object.keys(e);for(a=0;a<n.length;a++)i=n[a],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)i=n[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var s=r.a.createContext({}),u=function(e){var t=r.a.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):c({},t,{},e)),i},p=function(e){var t=u(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var i=e.components,a=e.mdxType,n=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=u(i),d=a,m=p["".concat(o,".").concat(d)]||p[d]||b[d]||n;return i?r.a.createElement(m,c({ref:t},s,{components:i})):r.a.createElement(m,c({ref:t},s))}));function m(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=i.length,o=new Array(n);o[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<n;s++)o[s]=i[s];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,i)}d.displayName="MDXCreateElement"}}]);